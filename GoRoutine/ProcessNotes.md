CPU本身无法区分线程和进程，尤其是对linux而言，线程和进程都是一样的，都是一个task_struct结构体 
早期单进程操作系统，那进程只能顺序执行 
单进程就出现了两个问题 
1. 单一执行流程、计算机只能一个任务一个任务的处理 
2. 进程阻塞所带来的CPU浪费问题 

如何解决上述问题：多线程/多进程操作系统（还是一个CPU），这个就是并发 
所以实际CPU还是同一时间只能做一件事，这个主要解决了阻塞问题 
CPU调度器根据算法（时间片轮询）来调度进程 

但是上面这个做法就会造成切换成本 
所以如果进程/线程的数量越多，切换成本就越大，也就越浪费 
原因: 
1. 假设一个CPU在切换两个线程时，需要保存和恢复10个寄存器的值，那么在切换4个线程时，就需要保存和恢复40个寄存器的值。 
   因此，随着线程数量的增加，CPU需要保存和恢复的上下文信息也会增多，从而导致线程切换的开销增加。 
2. 当线程数量增多时，每个线程的时间片也会相应减少，这会增加线程切换的频率。 
   尤其是在高并发的情况下，线程切换的频率可能会非常高，从而导致CPU花费大量时间在线程切换上，而不是真正执行任务。 

进程占用内存（虚拟内存约4GB）线程占用约4MB 
所以上述模型的两个大弊端：
1. 高消耗调度CPU 
2. 高消耗内存

**如何解决上述问题！！！！** 
一个线程有用户空间和内核空间， 
思考，能否把这两个完全切开，通过绑定关系绑定， 
所以这样CPU能看见的只有内核空间，他认为的线程只有这么大 
这时，我们把用户空间线程称为协程（co-routine），内核空间线程称为线程 

**所以就有了协程** 
用户空间有协程和协程调度器，协程调度器绑定线程（内核空间）（N:1） 

这种有缺陷，一个co-routine阻塞，后面的协程也会阻塞。 
原因： 
在一个共享内核的操作系统中，所有的协程都运行在同一个进程中，共享同一个内核线程。 
当一个协程阻塞时，它会通过系统调用将控制权交还给内核。此时，内核会根据调度算法选择一个协程来执行， 
但是由于内核线程只有一个，所以在任何一个时间点，只有一个协程能够运行。 
其他的协程必须等待当前正在运行的协程释放掉内核线程的控制权才能继续执行。 


解决办法：内核空间多个线程，每个线程绑定协程调度器，协程调度器绑定多个协程（N:M） 
所以这样问题就转变为 优化协程调度器 