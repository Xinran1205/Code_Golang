
//切记一个新学的知识：free完堆内存，要把指针设置为NULL
//指针free之后，free函数只是把指针指向的内存空间释放了，即内存中存储的值，但是并没有将指针的值赋为NULL，指针仍然指向这块内存。
//而程序判断一个指针是否合法，通常都是使用if语句测试该指针是否为NULL来判断，导致指针成为所谓的“野指针”，诱导误操作

//首先我们需要哪些函数呢？

//1.创建线程池，此函数返回一个线程池，入参应该是最小线程数，最大线程数和任务最大容量

//2.需要一个工作函数（消费者），void* worker（void* arg）

//3.需要一个管理者函数来创建**一个**管理者线程来管理 void* manage （void* arg）

//4.退出线程的函数 void threadexit（threadpool* pool）

//下面两个函数和第一个函数是对外的函数，用户调用接口
//5.销毁线程池的函数 int destroypool（threadpool* pool）

//6.添加任务的函数（生产者） void addtask（threadPool* pool，void(*func)(void*)，void* arg）


//开始写
//定义任务结构体 两个东西 函数和参数

//定义线程池结构体，17个
//这个明早写的时候删掉，一般边写边加
//属性：1任务2任务容量，3.现在有多少任务 4.头指针，5.尾指针
// 6.pthread_t管理者线程  7.工作者线程（是个指针）8.最小线程数9.最大线程数10.忙线程数 11.存活线程数 12.要销毁的线程数 13.pthread_mutex_t锁整个池的 14.锁忙线程的 
//15.16. pthread_cond_t两个条件变量empty和full 17. 线程池是否关闭

//1.创建线程池
//把上面这17个变量初始化，要开一个管理者线程执行manage函数和多个工作者线程执行worker函数

//2.需要一个工作函数（消费者）
//就是先卡住在那wait，等待signal（broadcast），当可以了，还得判断此时要不要销毁线程，然后需要判断一下线程池关了吗
//然后就可以拿出任务了，拿出后唤醒生产者，然后运行任务，运行前忙线程++，运行完--

//3.管理者
//就干两个事，3.1在什么条件下，要加线程（就是pthread_create，但是注意一下，在哪创建？遍历到0号线程)
//3.2在什么条件下，要销毁线程（这个其实就是唤醒工作线程，让他来销毁）
//这里面要很注意，我们需要取很多变量，都是要加锁的

//4.退出线程的函数，这个函数是在worker中调用的一个函数，当要退出当前线程时就调用这个函数
//这个函数要记得把不用的这个线程的id设置为0

//5.销毁线程池的函数
//先把第17个变量改了，然后阻塞收回管理者线程，因为管理者会循环判断第17个变量
//然后循环唤醒消费者线程
//然后释放堆内存，哪些是malloc的就free那些，然后摧毁锁和条件变量
//最后释放池

//6.添加任务
//思考，他是一个生产者，那他的一开始那句就和上面worker很像，对称的样子，阻塞wait
//然后他做的事情很简单，就是把任务添加到队列里面就行了，赋值，然后记得尾指针后移
//然后添加完就可以告诉消费者